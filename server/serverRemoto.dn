uses data.String

component provides App requires io.Output out, data.IntUtil iu, net.TCPSocket, 
                                net.TCPServerSocket, data.json.JSONEncoder encoder {

    int read_header(TCPSocket client){
        char buffer[]

        while(true){
            buffer = client.recv(1)
            if(buffer[0] == "\r"){
                size_file = iu.intFromString(header)
                break
            }
            header = new char[](payload, buffer)
        }
        return size_file
    }

    char[] read_field(TCPSocket client){
        char buffer[]

        while(true){
            buffer = client.recv(1)
            if(buffer[0] == "\r"){
                return header
            }
            header = new char[](payload, buffer)
        }
    }
    
    void readSocket(TCPSocket client){
        
        char payload[]
        int size_file = read_header(client)
        payload = client.recv(size_file)
        out.println("data recived")

        //JSONElement rows[] = parser.parseDocument(payload)
        //Data response[] = sort.sorting(parser.documentToString(rows), String.[string], true)

        String rows[] = encoder.jsonToArray(payload, typeof(String[]), null)

        for(int i=0; i<rows.arrayLength; i++){
            out.println("$(rows[i].string)")
        } 
        // String sorted[] = sort.sorting(rows, String.[string], true)

        client.send("teste")
        client.disconnect()
    }


	int App:main(AppParam params[]) {
		TCPServerSocket host = new TCPServerSocket()

		if (!host.bind(TCPServerSocket.ANY_ADDRESS, 2020)) {
			out.println("Error: failed to bind master socket")
			return 1
		}
		while (true) {
			TCPSocket client = new TCPSocket()
			if (client.accept(host)) {
                asynch::readSocket(client)
            }
		}
		return 0
	}
}